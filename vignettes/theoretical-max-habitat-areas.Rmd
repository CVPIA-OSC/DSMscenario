---
title: "Theoretical Max Habitat Areas"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Theoretical Max Habitat Areas}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE, message=FALSE}
library(DSMscenario)
library(tidyverse)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message=FALSE 
)
```

## Total Wetted Area Estimation

We used 1 meter resolution 4 band (R, G, B, N) imagery from the National Agriculture Imagery Program [(NAIP)](fsa.usda.gov/programs-and-services/aerial-photography/imagery-programs/naip-imagery/) to conduct  a Normalized Difference Water Index [(NDWI)](https://en.wikipedia.org/wiki/Normalized_difference_water_index) based analysis to identify total wetted area for the 31 tributaries included in the SIT chinook life cycle models. The analysis was performed using the [Google Earth Engine IDE](https://code.earthengine.google.com/).

We used all the available NAIP imagery for the years 2009-2016 and for each image calculated the NDWI as:
$${NDWI}=\frac{(Xgreen - Xnir)}{(Xgreen + Xnir)}$$

We then reduced the multidimensional array of NDWI rasters by selecting the maximum NDWI at each pixel. We created a buffer of the fall run rearing extents with an estimated channel width to clip the max NDWI raster. A binary filter was applied to the clipped raster for NDWI values greater than a threshold to classify each pixel as water or not water. These
water pixels were multiplied by the pixel area and then all summed to estimate the total wetted area of the stream.

The total wetted area values for each watershed were recorded in this file:  `data-raw/earth_engine_total_channel_area_estimates.csv`

The extents were mapped through expert outreach can be viewed on [this interactive map](https://cvpia-osc.github.io/DSMhabitat/articles/habitat-extents-map.html) and are available for download [here](https://github.com/CVPIA-OSC/DSMhabitat/tree/main/data-raw/rearing_spatial_data/salmonid_habitat_extents)


### Example analysis JavaScript code below:

```{javascript eval=F}
var naip: Imagecollection "NAIP: National Agriculture Imagery Program"
var habExt = ee.FeatureCollection('users/fall_run_hab_extent');

// Lower-mid Sacramento River 
var lowerMidSacRiver = ee.Feature(habExt.filterMetadata('River', 'equals', 'Lower-mid Sacramento River').first());

// define buffer
var lowerMidSacRiverBuffer= lowerMidSacRiver.buffer(70);

// 2009-2016 NAIP imagery covering Lower Sacramento River
var lowerMidSac = naip
  .filterBounds(lowerMidSacRiver.geometry())
  .filterDate('2009-01-01','2016-12-31');

// calculate ndwi for each image
var ndwi = lowerMidSac.map(function(img) {
    return img.normalizedDifference(['G', 'N']).rename('ndwi');
});

var maxNDWI = ndwi
  .reduce(ee.Reducer.max());

var mask = maxNDWI.mask(maxNDWI.gt(.7));

// simple water classifier
var water = maxNDWI
  .gt(.7)
  .multiply(ee.Image.pixelArea())
  .rename('waterAreaSqMeters')
  .reduceRegion({
    reducer: ee.Reducer.sum(), 
    geometry: lowerMidSacRiverBuffer.geometry(), 
    scale: 1,
    maxPixels: 1e9
  });
  
print('total water area in square meters:', water);
```

## Estimated Maximum Possible Suitable Habitat

We assumed 30% of the total wetted area in the mapped spawning extents based on the concept that spawnable riffles generally comprise approximately 1/3 of the geomorphic units (i.e. 1/3 riffles, 1/3 pools, and 1/3 runs) in a salmonid spawning reach of river. We assume 50% of the total wetted area in the mapped rearing extents based on the concept that 50% of the area is the main active channel and 25% on either side is the suitable rearing area that is riparian influenced channel area (vegetated, shallower, etc). 

```{r}
wetted_area <- read_csv('data-raw/earth_engine_total_channel_area_estimates.csv')

length_ratios <- DSMhabitat::watershed_lengths %>% 
  filter(species == 'fr') %>%
  select(watershed, lifestage, feet) %>%
  spread(lifestage, feet) %>% 
  transmute(watershed, sr_ratio = spawning/rearing)

max_area_fr <- wetted_area %>% 
  left_join(length_ratios) %>% 
  transmute(watershed = factor(watershed, levels = DSMscenario::watershed_labels),
            rearing_sqm = .5 *
              DSMhabitat::acres_to_square_meters(FR_channel_area_of_length_modeled_acres),
            spawning_sqm = rearing_sqm * sr_ratio * .6) %>% # .5 * .6 = .3
  arrange(watershed)


fr_rear_max <- max_area_fr %>% 
  pull(rearing_sqm) %>% 
  set_names(DSMscenario::watershed_labels)

fr_spawn_max <- max_area_fr %>% 
  pull(spawning_sqm) %>% 
  set_names(DSMscenario::watershed_labels)
```

To estimate the maximum suitable area for other species, we scale the fall run 
rearing estimates using the rearing extent length ratio between fall run and the target species. To estimate the spawning maximum suitable area, we scale the target species rearing estimate using the ratio of spawning:rearing extent lengths for that species.

The method is demonstrated for Spring Run below:
```{r}
fr_lengths <- DSMhabitat::watershed_lengths %>% 
  filter(species == "fr", lifestage == "rearing") %>% 
  select(watershed,fr_rear_feet = feet)

sr_ratios <- DSMhabitat::watershed_lengths %>% 
  filter(species == "sr") %>% 
  select(watershed, feet, lifestage) %>% 
  spread(lifestage, feet) %>% 
  right_join(fr_lengths) %>% 
  transmute(watershed = factor(watershed, levels = DSMscenario::watershed_labels),
            sr_spw_ratio = spawning/fr_rear_feet, sr_rear_ratio = rearing/fr_rear_feet) %>% 
  arrange(watershed)

sr_spawn_max <- numeric(31) %>% set_names(DSMscenario::watershed_labels)
sr_spawn_max <- fr_rear_max * sr_ratios$sr_spw_ratio

sr_rear_max <- numeric(31) %>% set_names(DSMscenario::watershed_labels)
sr_rear_max <- fr_rear_max * sr_ratios$sr_rear_ratio * 0.6
```


```{r, include=FALSE}
wr_ratios <- DSMhabitat::watershed_lengths %>% 
  filter(species == "wr") %>% 
  select(watershed, feet, lifestage) %>% 
  spread(lifestage, feet) %>% 
  right_join(fr_lengths) %>% 
  transmute(watershed = factor(watershed, levels = DSMscenario::watershed_labels),
            wr_spw_ratio = spawning/fr_rear_feet, wr_rear_ratio = rearing/fr_rear_feet) %>% 
  arrange(watershed)

wr_rear_max <- numeric(31) %>% set_names(DSMscenario::watershed_labels)
wr_rear_max <- fr_rear_max * wr_ratios$wr_rear_ratio

sacramento_reaches <- c("Upper Sacramento River", "Upper-mid Sacramento River",
                        "Lower-mid Sacramento River", "Lower Sacramento River")
wr_rear_max[sacramento_reaches] <- fr_rear_max[sacramento_reaches]

wr_spawn_max <- numeric(31) %>% set_names(DSMscenario::watershed_labels)
wr_spawn_max <- fr_rear_max * wr_ratios$wr_spw_ratio  * 0.6
wr_spawn_max["Upper Sacramento River"] <- fr_spawn_max["Upper Sacramento River"]
```

```{r include=FALSE}
st_ratios <- DSMhabitat::watershed_lengths %>% 
  filter(species == "st") %>% 
  select(watershed, feet, lifestage) %>% 
  spread(lifestage, feet) %>% 
  right_join(fr_lengths) %>% 
  transmute(watershed = factor(watershed, levels = DSMscenario::watershed_labels),
            st_spw_ratio = spawning/fr_rear_feet, st_rear_ratio = rearing/fr_rear_feet) %>% 
  arrange(watershed)

st_spawn_max <- numeric(31) %>% set_names(DSMscenario::watershed_labels)
st_spawn_max <- fr_rear_max * st_ratios$st_spw_ratio  * 0.6

st_rear_max <- numeric(31) %>% set_names(DSMscenario::watershed_labels)
st_rear_max <- fr_rear_max * st_ratios$st_rear_ratio

```

## Compare Proposed Theoretical Maximum to Modeled Maximum Habitat Values

```{r}
max_existing_habitat_fr_rear <- set_names(pmax(purrr::map_dbl(1:31, ~max(DSMhabitat::fr_fry[.,,])),
                                               purrr::map_dbl(1:31, ~max(DSMhabitat::fr_juv[.,,]))),
                                          DSMscenario::watershed_labels)

max_existing_habitat_fr_spawn <- set_names(purrr::map_dbl(1:31, ~max(DSMhabitat::fr_spawn[.,,])),
                                           DSMscenario::watershed_labels)

max_existing_habitat_wr_rear <- set_names(pmax(purrr::map_dbl(1:31, ~max(DSMhabitat::wr_fry[.,,])),
                                               purrr::map_dbl(1:31, ~max(DSMhabitat::wr_juv[.,,]))),
                                     DSMscenario::watershed_labels)

max_existing_habitat_wr_spawn <- set_names(purrr::map_dbl(1:31, ~max(DSMhabitat::wr_spawn[.,,])),
                                           DSMscenario::watershed_labels)

max_existing_habitat_sr_rear <- set_names(pmax(purrr::map_dbl(1:31, ~max(DSMhabitat::sr_fry[.,,])),
                                               purrr::map_dbl(1:31, ~max(DSMhabitat::sr_juv[.,,]))),
                                          DSMscenario::watershed_labels)
max_existing_habitat_sr_spawn <- set_names(purrr::map_dbl(1:31, ~max(DSMhabitat::sr_spawn[.,,])),
                                           DSMscenario::watershed_labels)

max_existing_habitat_st_rear <- set_names(pmax(purrr::map_dbl(1:31, ~max(DSMhabitat::st_fry[.,,])),
                                               purrr::map_dbl(1:31, ~max(DSMhabitat::st_juv[.,,]))),
                                          DSMscenario::watershed_labels)
max_existing_habitat_st_spawn <- set_names(purrr::map_dbl(1:31, ~max(DSMhabitat::st_spawn[.,,])),
                                           DSMscenario::watershed_labels)




# TODO when late fall run is cached
# max_existing_habitat_lfr_rear <- pmax(purrr::map_dbl(1:31, ~max(DSMhabitat::lfr_lfry[.,,])),
#                                      purrr::map_dbl(1:31, ~max(DSMhabitat::lfr_juv[.,,])))
# 
# max_existing_habitat_lfr_spawn <- set_names(DSMscenario::watershed_labels, purrr::map_dbl(1:31, ~max(DSMhabitat::lfr_spawn[.,,]))

```
The following watersheds' estimated maximum habitat are less than the maximum value of modeled habitat during the simulation period: `r glue::glue_collapse(DSMscenario::watershed_labels[(fr_rear_max < max_existing_habitat_fr_rear) & !is.na(fr_rear_max)], sep = ", ")`

And for spawning:
`r glue::glue_collapse(DSMscenario::watershed_labels[(fr_spawn_max < max_existing_habitat_fr_spawn) & !is.na(fr_spawn_max)], sep = ", ")`

TODO what new method

```{r}
DSMhabitat::cow_creek_instream$flow_cfs[DSMhabitat::cow_creek_instream$FR_fry_wua == max(DSMhabitat::cow_creek_instream$FR_fry_wua)]
DSMhabitat::cow_creek_instream$flow_cfs[DSMhabitat::cow_creek_instream$FR_juv_wua == max(DSMhabitat::cow_creek_instream$FR_juv_wua)]
DSMscenario::watershed_labels[9]
max_existing_habitat_fr_rear[9]

max(DSMhabitat::fr_fry["Cow Creek",,])
DSMhabitat::set_instream_habitat("Cow Creek", 'fr', 'fry', 200)
```

Cache spawning and rearing maximum areas for each species.
```{r eval=F}

max_rear_area <- list(
  "fall" = fr_rear_max,
  "winter" = wr_rear_max,
  "spring" = sr_rear_max,
  "steelhead" = st_rear_max)

max_spawn_area <- list(
  "fall" = fr_spawn_max,
  "winter" = wr_spawn_max,
  "spring" = sr_spawn_max,
  "steelhead" = st_spawn_max)


# max_rear_area <- list(
#   "fall" = max_existing_habitat_fr_rear * 1.5,
#   "winter" = max_existing_habitat_wr_rear * 1.5,
#   "spring" = max_existing_habitat_sr_rear * 1.5,
#   "steelhead" = max_existing_habitat_st_rear * 1.5)
# 
# max_spawn_area <- list(
#   "fall" = max_existing_habitat_fr_spawn * 1.5,
#   "winter" = max_existing_habitat_wr_spawn * 1.5,
#   "spring" = max_existing_habitat_sr_spawn * 1.5,
#   "steelhead" = max_existing_habitat_st_spawn * 1.5)

usethis::use_data(max_spawn_area, overwrite = TRUE)
usethis::use_data(max_rear_area, overwrite = TRUE)
```

```{r}
sum(fr_rear_max < (max_existing_habitat_fr_rear * 1.5), na.rm = TRUE)
sum(wr_rear_max > (max_existing_habitat_wr_rear * 1.5), na.rm = TRUE)/(sum(!is.na(wr_rear_max)))
```
